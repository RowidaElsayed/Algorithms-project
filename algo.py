# -*- coding: utf-8 -*-
"""Algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13O6h2wjYSY1fyb3Zr1ZoxUv6UcXYMq1U
"""

import networkx as nx
import community

# Load Facebook data into a NetworkX graph
G = nx.read_edgelist("facebook_combined.txt")

# Degree distribution analysis
degree_sequence = sorted([d for n, d in G.degree()], reverse=True)
degree_count = nx.degree_histogram(G)

# Path analysis
shortest_paths = dict(nx.all_pairs_shortest_path_length(G))

# Centrality analysis
degree_centrality = nx.degree_centrality(G)
closeness_centrality = nx.closeness_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G)
eigenvector_centrality = nx.eigenvector_centrality(G)

# Connected components analysis
num_components = nx.number_connected_components(G)
largest_component = max(nx.connected_components(G), key=len)

# Clustering coefficients
avg_clustering_coefficient = nx.average_clustering(G)

# Density analysis
density = nx.density(G)

# Network type
if nx.is_directed(G):
    print("Graph is directed")
else:
    print("Graph is undirected")
    
if nx.is_weighted(G):
    print("Graph is weighted")
else:
    print("Graph is unweighted")

!pip install infomap

!pip install python-louvain

import networkx as nx
from community.community_louvain import best_partition

# Load Facebook data into a NetworkX graph
G = nx.read_edgelist("facebook_combined.txt")

# Perform community detection using the Louvain algorithm
partition = best_partition(G)

# Print the communities
for com in set(partition.values()):
    nodes = [node for node in partition.keys() if partition[node] == com]
    print("Community", com, ":", nodes)

# Load Facebook data into a NetworkX graph
G = nx.read_edgelist("facebook_combined.txt")

# Degree distribution analysis
degree_sequence = sorted([d for n, d in G.degree()], reverse=True)
degree_count = nx.degree_histogram(G)

# Path analysis
shortest_paths = dict(nx.all_pairs_shortest_path_length(G))

# Centrality analysis
degree_centrality = nx.degree_centrality(G)
closeness_centrality = nx.closeness_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G)
eigenvector_centrality = nx.eigenvector_centrality(G)

# Connected components analysis
num_components = nx.number_connected_components(G)
largest_component = max(nx.connected_components(G), key=len)

# Clustering coefficients
avg_clustering_coefficient = nx.average_clustering(G)

# Density analysis
density = nx.density(G)

# Network type
if nx.is_directed(G):
    print("Graph is directed")
else:
    print("Graph is undirected")
    
if nx.is_weighted(G):
    print("Graph is weighted")
else:
    print("Graph is unweighted")

import networkx as nx
from infomap import Infomap

# Load Facebook data into a NetworkX graph
G = nx.read_edgelist("facebook_combined.txt")

# Create an Infomap object and add links from the NetworkX graph
im = Infomap()
for u, v in G.edges():
    im.addLink(int(u), int(v))

# Run the Infomap algorithm and print the modules
im.run()
for node in im.tree:
    if node.isLeaf:
        print(f"Node {node.physicalId} belongs to module {node.moduleIndex}")

# Print the results
print("Degree distribution:", degree_count)
print("Shortest paths:", shortest_paths)
print("Degree centrality:", degree_centrality)
print("Closeness centrality:", closeness_centrality)
print("Betweenness centrality:", betweenness_centrality)
print("Eigenvector centrality:", eigenvector_centrality)
print("Number of connected components:", num_components)
print("Largest connected component:", largest_component)
print("Average clustering coefficient:", avg_clustering_coefficient)
print("Density:", density)

print("Network type:")
if nx.is_directed(G):
    print("Directed")
else:
    print("Undirected")
    
if nx.is_weighted(G):
    print("Weighted")
else:
    print("Unweighted")
    
print("Community discovery:")
for com in set(partition.values()):
    nodes = [node for node in partition.keys() if partition[node] == com]
    print("Community", com, ":", nodes)

print("Dynamic community discovery:")
for node in im.iterTree():
    if node.isLeaf():
        print("Community", node.moduleIndex(), ":", node.physicalId)

import matplotlib.pyplot as plt

plt.figure(figsize=(10,10))
pos = nx.spring_layout(G, seed=42)

# Define node colors
for n in G.nodes:
    G.nodes[n]['color'] = 'blue' # Replace 'blue' with the desired color for each node
node_colors = [G.nodes[n]['color'] for n in G.nodes]

# Draw the graph
nx.draw(G, pos, node_color=node_colors, with_labels=False, node_size=10)

# Display the plot
plt.show()